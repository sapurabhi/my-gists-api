# .github/workflows/cd.yaml
name: CD: Deploy to EKS

on:
  push:
    branches:
      - solution # Trigger deployment on push to 'solution' branch (after CI completes)

jobs:
  deploy:
    runs-on: ubuntu-latest
    needs: build-and-push-image # Ensure CI job (renamed) completes and image is pushed
    permissions:
      id-token: write # Required for OIDC authentication with AWS
      contents: read # To checkout the repository and download artifacts

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Download image tag artifact
        uses: actions/download-artifact@v4
        with:
          name: image-tag-artifact # Must match the artifact name from CI workflow
          path: ./ # Download to the current directory

      - name: Read image tag from file
        id: read_tag
        run: |
          # The image-tag-artifact is a file named image-tag.txt
          # Read its content and set it as a step output.
          IMAGE_TAG=$(cat ./image-tag-artifact/image-tag.txt) # Assuming artifact downloads to a subfolder
          echo "Retrieved IMAGE_TAG for deployment: $IMAGE_TAG"
          echo "image_tag=$IMAGE_TAG" >> $GITHUB_OUTPUT # Set as output for the step

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/${{ vars.GITHUB_ACTIONS_DEPLOYER_ROLE_NAME }}
          aws-region: ${{ secrets.AWS_REGION }}
          # Ensure `mask-for-sops` or similar is not needed if this is a non-sensitive role

      - name: Set up Kubectl and EKS context
        uses: aws-actions/amazon-eks-setup@v2
        with:
          cluster-name: ${{ vars.EKS_CLUSTER_NAME }} # Use the EKS cluster name from GitHub Actions Variables
          config-files: ~/.kube/config # Ensures kubeconfig is updated

      - name: Install Helm
        uses: azure/setup-helm@v1
        with:
          version: '3.14.0' # Specify Helm version for consistency

      - name: Get ECR repository URL for CD
        id: get-ecr-url-cd
        # Replace 'simple-gists-api-gists-api' with your actual ECR repository name
        run: |
          ECR_REPO_URL=$(aws ecr describe-repositories --repository-names simple-gists-api-gists-api --query 'repositories[0].repositoryUri' --output text)
          echo "ECR_REPO_URL=$ECR_REPO_URL" >> $GITHUB_ENV # Set as env var for subsequent steps

      - name: Deploy with Helm
        env:
          ECR_REPO_URL: ${{ env.ECR_REPO_URL }}
          IMAGE_TAG: ${{ steps.read_tag.outputs.image_tag }} # Use the tag from the artifact
        run: |
          echo "Deploying Helm chart with Image: $ECR_REPO_URL:$IMAGE_TAG"
          helm upgrade --install simple-gists-api-release ./helm/simple-gists-api \
            --namespace default \
            --create-namespace \
            --set image.repository=$ECR_REPO_URL \
            --set image.tag=$IMAGE_TAG \
            --set service.type=LoadBalancer \
            --atomic # Ensures a full rollback on failed upgrade

      - name: Wait for LoadBalancer to be ready
        id: lb_status
        run: |
          echo "Waiting for LoadBalancer IP/Hostname..."
          LB_ENDPOINT=""
          for i in $(seq 1 120); do # Wait up to 10 minutes (120 * 5s)
              # Try to get hostname first, then IP if hostname is empty
              LB_HOSTNAME=$(kubectl get svc simple-gists-api-service -n default -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
              if [ -n "$LB_HOSTNAME" ]; then
                  LB_ENDPOINT="$LB_HOSTNAME"
                  break
              fi
              LB_IP=$(kubectl get svc simple-gists-api-service -n default -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
              if [ -n "$LB_IP" ]; then
                  LB_ENDPOINT="$LB_IP"
                  break
              fi
              echo "Still waiting for LoadBalancer... $i/120"
              sleep 5
          done

          if [ -n "$LB_ENDPOINT" ]; then
              echo "LoadBalancer is ready: $LB_ENDPOINT"
              echo "lb_url=$LB_ENDPOINT" >> $GITHUB_OUTPUT # Set LoadBalancer URL as a step output
          else
              echo "Timeout waiting for LoadBalancer. Check service status with 'kubectl get svc simple-gists-api-service -n default'."
              exit 1
          fi

      - name: Verify Deployment (Optional)
        # Add a curl or HTTP GET request to the LoadBalancer URL to verify application health.
        # This requires the LB_ENDPOINT from the previous step.
        run: |
          if [ -n "${{ steps.lb_status.outputs.lb_url }}" ]; then
            echo "Verifying application at: http://${{ steps.lb_status.outputs.lb_url }}/health"
            curl -f --retry 10 --retry-connrefused --retry-max-time 60 http://${{ steps.lb_status.outputs.lb_url }}/health || { echo "Health check failed!"; exit 1; }
            echo "Application health check passed."
          else
            echo "LoadBalancer URL not available for health check."
          fi